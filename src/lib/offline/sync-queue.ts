/**
 * Sync Queue for Offline Operations
 *
 * This module manages a queue of operations that need to be synced with the server
 * when the application comes back online.
 */

import * as db from './db';

// Types of sync operations
export enum SyncOperation {
  CREATE = 'create',
  UPDATE = 'update',
  DELETE = 'delete'
}

// Status of sync queue items
export type SyncQueueStatus = 'pending' | 'processing' | 'completed' | 'failed';

// Structure of a sync queue item
export interface SyncQueueItem {
  id?: number;              // Auto-generated by IndexedDB
  entity_type: string;      // The store name (e.g., 'notes', 'tags')
  entity_id: string;        // The ID of the entity being synced
  operation: SyncOperation; // The operation to perform
  data: Record<string, unknown>;  // The data to sync
  timestamp: string;        // When the operation was queued
  status: SyncQueueStatus;  // Current status of this queue item
  error?: string;           // Error message if sync failed
  retry_count?: number;     // Number of retry attempts
}

/**
 * Add an operation to the sync queue
 */
export async function addToSyncQueue(item: SyncQueueItem): Promise<number> {
  try {
    // Set defaults
    const queueItem: SyncQueueItem = {
      ...item,
      timestamp: item.timestamp || new Date().toISOString(),
      status: item.status || 'pending',
      retry_count: 0
    };

    // Add to queue
    const id = await db.put(db.STORES.SYNC_QUEUE, queueItem);
    return id as number;
  } catch (error) {
    console.error('Error adding to sync queue:', error);
    throw new Error('Failed to queue operation for sync');
  }
}

/**
 * Get all pending items in the sync queue
 */
export async function getPendingSyncItems(): Promise<SyncQueueItem[]> {
  try {
    const allItems = await db.getAll<SyncQueueItem>(db.STORES.SYNC_QUEUE);
    return allItems.filter(item => item.status === 'pending');
  } catch (error) {
    console.error('Error getting pending sync items:', error);
    throw new Error('Failed to get pending sync operations');
  }
}

/**
 * Update a sync queue item's status
 */
export async function updateSyncItemStatus(
  id: number,
  status: SyncQueueStatus,
  error?: string
): Promise<void> {
  try {
    const item = await db.getById<SyncQueueItem>(db.STORES.SYNC_QUEUE, id);
    if (item) {
      const updatedItem: SyncQueueItem = {
        ...item,
        status,
        error,
        retry_count: status === 'failed' ? (item.retry_count || 0) + 1 : item.retry_count
      };
      await db.put(db.STORES.SYNC_QUEUE, updatedItem);
    }
  } catch (error) {
    console.error('Error updating sync item status:', error);
    throw new Error('Failed to update sync operation status');
  }
}

/**
 * Remove completed sync items from the queue
 */
export async function cleanupCompletedSyncItems(): Promise<void> {
  try {
    const allItems = await db.getAll<SyncQueueItem>(db.STORES.SYNC_QUEUE);
    const completed = allItems.filter(item => item.status === 'completed');

    const database = await db.initDB();
    const transaction = database.transaction(db.STORES.SYNC_QUEUE, 'readwrite');
    const store = transaction.objectStore(db.STORES.SYNC_QUEUE);

    for (const item of completed) {
      if (item.id) {
        store.delete(item.id);
      }
    }

    // Wait for transaction to complete
    return new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
    });
  } catch (error) {
    console.error('Error cleaning up completed sync items:', error);
    throw new Error('Failed to clean up sync queue');
  }
}